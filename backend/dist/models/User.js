"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserModel = void 0;
const db_1 = __importDefault(require("../database/db"));
const bcryptjs_1 = __importDefault(require("bcryptjs"));
exports.UserModel = {
    async findByEmail(email) {
        if (!email)
            return null;
        const [rows] = await db_1.default.query("SELECT * FROM Users WHERE email = ? LIMIT 1", [email]);
        return rows[0] || null;
    },
    async findByPhone(phone) {
        if (!phone)
            return null;
        const [rows] = await db_1.default.query("SELECT * FROM Users WHERE phone_number = ? LIMIT 1", [phone]);
        return rows[0] || null;
    },
    async findById(userId) {
        const [rows] = await db_1.default.query("SELECT * FROM Users WHERE user_id = ? LIMIT 1", [userId]);
        return rows[0] || null;
    },
    async create(data) {
        // Expect to return inserted id (UUID generated by DB triggers)
        const fields = [];
        const placeholders = [];
        const values = [];
        // Map allowed fields
        const allowed = [
            "fullname",
            "email",
            "phone_number",
            "password",
            "country_code",
            "type_login",
            "role",
            "google_id",
            "avatar",
            "avatar_path",
            "address",
            "gender",
            "date_of_birth",
        ];
        for (const key of allowed) {
            // @ts-ignore
            if (data[key] !== undefined) {
                fields.push(key);
                placeholders.push("?");
                // hash password if provided and non-empty
                if (key === "password" && data.password) {
                    const hashed = await bcryptjs_1.default.hash(String(data.password), 10);
                    values.push(hashed);
                }
                else {
                    // @ts-ignore
                    values.push(data[key]);
                }
            }
        }
        const sql = `INSERT INTO Users (${fields.join(",")}) VALUES (${placeholders.join(",")})`;
        const [result] = await db_1.default.query(sql, values);
        // When UUID trigger used, we can fetch by result.insertId not available for CHAR primary; return null or find by unique field.
        // Try to return user_id by searching email or google_id or phone
        if (data.email) {
            const user = await this.findByEmail(String(data.email));
            return user ? user.user_id : null;
        }
        if (data.google_id) {
            const [rows] = await db_1.default.query("SELECT * FROM Users WHERE google_id = ? LIMIT 1", [data.google_id]);
            return rows[0]?.user_id || null;
        }
        return null;
    },
    async verifyPassword(plain, hashed) {
        if (!hashed)
            return false;
        return bcryptjs_1.default.compare(plain, hashed);
    },
    async updateLastLogin(userId) {
        await db_1.default.query("UPDATE Users SET last_login = NOW(), is_online = 1 WHERE user_id = ?", [userId]);
        return true;
    },
    async update(userId, updateData) {
        const sets = [];
        const values = [];
        for (const key in updateData) {
            if (key === "password" && updateData.password) {
                // hash password
                // @ts-ignore
                const hashed = await bcryptjs_1.default.hash(String(updateData.password), 10);
                sets.push(`${key} = ?`);
                values.push(hashed);
            }
            else {
                sets.push(`${key} = ?`);
                // @ts-ignore
                values.push(updateData[key]);
            }
        }
        if (sets.length === 0)
            return false;
        values.push(userId);
        const sql = `UPDATE Users SET ${sets.join(", ")} WHERE user_id = ?`;
        const [result] = await db_1.default.query(sql, values);
        return result.affectedRows > 0;
    },
    async setOffline(userId) {
        await db_1.default.query("UPDATE Users SET is_online = 0 WHERE user_id = ?", [userId]);
        return true;
    },
};
