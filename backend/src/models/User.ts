import pool from "../database/db";
import bcrypt from "bcryptjs";

export interface IUser {
    user_id?: string;
    fullname?: string;
    email?: string | null;
    phone_number?: string | null;
    password?: string | null;
    country_code?: string;
    type_login?: string;
    role?: string;
    avatar?: string | null;
    google_id?: string | null;
    last_login?: Date | null;
    // ...other fields
}

export const UserModel = {
    async findByEmail(email: string) {
        if (!email) return null;
        const [rows]: any = await pool.query("SELECT * FROM Users WHERE email = ? LIMIT 1", [email]);
        return rows[0] || null;
    },

    async findByPhone(phone: string | null) {
        if (!phone) return null;
        const [rows]: any = await pool.query("SELECT * FROM Users WHERE phone_number = ? LIMIT 1", [phone]);
        return rows[0] || null;
    },

    async findById(userId: string) {
        const [rows]: any = await pool.query("SELECT * FROM Users WHERE user_id = ? LIMIT 1", [userId]);
        return rows[0] || null;
    },

    async create(data: Partial<IUser>) {
        // Expect to return inserted id (UUID generated by DB triggers)
        const fields: string[] = [];
        const placeholders: string[] = [];
        const values: any[] = [];

        // Map allowed fields
        const allowed = [
            "fullname",
            "email",
            "phone_number",
            "password",
            "country_code",
            "type_login",
            "role",
            "google_id",
            "avatar",
            "avatar_path",
            "address",
            "gender",
            "date_of_birth",
        ];
        for (const key of allowed) {
            // @ts-ignore
            if (data[key] !== undefined) {
                fields.push(key);
                placeholders.push("?");
                // hash password if provided and non-empty
                if (key === "password" && data.password) {
                    const hashed = await bcrypt.hash(String(data.password), 10);
                    values.push(hashed);
                } else {
                    // @ts-ignore
                    values.push(data[key]);
                }
            }
        }

        const sql = `INSERT INTO Users (${fields.join(",")}) VALUES (${placeholders.join(",")})`;
        const [result]: any = await pool.query(sql, values);
        // When UUID trigger used, we can fetch by result.insertId not available for CHAR primary; return null or find by unique field.
        // Try to return user_id by searching email or google_id or phone
        if (data.email) {
            const user = await this.findByEmail(String(data.email));
            return user ? user.user_id : null;
        }
        if (data.google_id) {
            const [rows]: any = await pool.query("SELECT * FROM Users WHERE google_id = ? LIMIT 1", [data.google_id]);
            return rows[0]?.user_id || null;
        }
        return null;
    },

    async verifyPassword(plain: string, hashed: string | undefined | null) {
        if (!hashed) return false;
        return bcrypt.compare(plain, hashed);
    },

    async updateLastLogin(userId: string) {
        await pool.query("UPDATE Users SET last_login = NOW(), is_online = 1 WHERE user_id = ?", [userId]);
        return true;
    },

    async update(userId: string, updateData: Record<string, unknown>) {
        const sets: string[] = [];
        const values: any[] = [];
        for (const key in updateData) {
            if (key === "password" && updateData.password) {
                // hash password
                // @ts-ignore
                const hashed = await bcrypt.hash(String(updateData.password), 10);
                sets.push(`${key} = ?`);
                values.push(hashed);
            } else {
                sets.push(`${key} = ?`);
                // @ts-ignore
                values.push(updateData[key]);
            }
        }
        if (sets.length === 0) return false;
        values.push(userId);
        const sql = `UPDATE Users SET ${sets.join(", ")} WHERE user_id = ?`;
        const [result]: any = await pool.query(sql, values);
        return result.affectedRows > 0;
    },

    async setOffline(userId: string) {
        await pool.query("UPDATE Users SET is_online = 0 WHERE user_id = ?", [userId]);
        return true;
    },
};
